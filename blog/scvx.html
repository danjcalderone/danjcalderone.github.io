<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></link>
    <meta http-equiv="X-UA-Compatible" content="ie=edge" ></link>

    <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.css"
    integrity="sha384-Cqd8ihRLum0CCg8rz0hYKPoLZ3uw+gES2rXQXycqnL5pgVQIflxAUDS7ZSjITLb5"
    crossorigin="anonymous"></link>

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.js"
    integrity="sha384-1Or6BdeNQb0ezrmtGeqQHFpppNd7a/gw29xeiSikBbsb44xu3uAo8c7FwbF5jhbd"
    crossorigin="anonymous"></script>
  <!-- To automatically render math in text elements, include the auto-render extension: -->

  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/contrib/auto-render.min.js"
    integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"
    crossorigin="anonymous"
    onload="renderMathInElement(document.body)">
    </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.2.5/math.min.js"> </script>
  <script src="https://unpkg.com/pts@0.10.5/dist/pts.js"></script>


    <!-- <link rel="stylesheet" href="./css/main.css" ></link> -->


    <style>

.img1 {
  background-color: rgb(0, 0, 255, 0);
  flex: 0 1 auto;
  padding: 0px;
  margin: 0px;
  position: relative;
  top: 0px;
  left: 0px;
  width: 95%;
  aspect-ratio: 1 / 1;
  /* height: 900px; */
}
.img1 .CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  top: 0;
  left: 0;
  position: absolute;
  margin: 0px;
  padding: 0px;
  width: 100%;
  height: 100%;
}

.img2 {
  background-color: rgb(0, 0, 255, 0);
  flex: 0 1 auto;
  padding: 0px;
  margin: 0px;
  position: relative;
  top: 0px;
  left: 0px;
  width: 95%;
  aspect-ratio: 2 / 1;
  /* height: 900px; */
}

.img2 .CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  top: 0;
  left: 0;
  position: absolute;
  margin: 0px;
  padding: 0px;
  width: 100%;
  height: 100%;
}


.CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  position: absolute;
  top: 0;
  left: 0;
  width: 1400px;
  height: 1400px;
}
.eqn1 {
  background-color: rgba(0, 0, 255, 0);
  color: black;
  position: absolute;
  font-size: 16px;
  top: 0px;
  left: 0px;
  z-index: -1;
}





  </style>

  <link rel="stylesheet" href="/Users/dan/Documents/danjcalderone.github.io/css/main.css" ></link>
  <!-- <link rel="stylesheet" href="/Users/dan/Documents/danjcalderone.github.io/main.css" ></link> -->
  <!-- <link rel="stylesheet" href="/css/main.css" ></link> -->

    </head>

    <body>
    <header > <h1> danjcalderone </h1> </header>



    <div w3-include-html="/nav/topics.html"></div>



    <div class="wrapper">
      <div class="sidebar">
      <!-- <div w3-include-html="/nav/sidebarBLOG.html"></div> -->

 <ul>
    <h1><div id="header">Posts</div></h1>

    <h3> Optimization</h3>
    <li><a href="/blog/scvx.html"> Successive Convexification (Oct 23) </a> </li>
    <li><a href="/blog/scvx.html"> Matching + Planning (Oct 23) </a> </li>

    <h3> Linear Algebra</h3>
    <li><a href="/blog/inner.html"> Inner Product Visualizations (Oct 23) </a> </li>

  </ul>

      


      </div>
      <div class=main_content>


        <h1><div id="header">
          Successive Convexification (SCVX)
          <br> for Trajectory Planning
        </div></h1>


        <div class="section basic" >
        <div class="txt" style="padding:40px">



              <b> Problem Setup </b>
              <p>

              We consider a basic trajectory planning problem to get between two points.  We want to find a path between the starting and end point consistent with the dynamcis while avoiding the obstacles.  We will consider state vector \(x(t) \in \mathbb{R}^n\) for \(n=2,3\)
              and controls \(u(t) \in \mathbb{R}^n\) for \(n=2,3\) as well.  We consider the simple environments displayed here with given starting and ending locations, \(x_0\) and \(x_T\) respectively.
            </p>

                <div class='imgFixed' >
<!--                 <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/scvx/2Dinit.png" width=35%></img>
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/scvx/3Dinit.jpeg" width=35%></img>
 -->                
                <img src="/figs/blog/scvx/2Dinit.png" width=35%></img>
                <img src="/figs/blog/scvx/3Dinit.jpeg" width=35%></img>

                </div>


            <b> Dynamics:  </b>

              <p>
              In order to focus on the most basic trajectory planning, we start with the most basic, single-integrator dynamics

              $$
              \begin{aligned}
              \dot{x}(t) = u(t)
              \end{aligned}
              $$
              We can now compute the discrete time dynamics
              $$
              \begin{aligned}
              x(t+\Delta t) & = Ax(t) + Bu(t) \\
              & = x(t) + \int_0^{\Delta t} B u(\tau) \ d\tau  = I + \Delta t \  u(t)
              \end{aligned}
              $$
              where here \(A \in \mathbb{R}^{n \times n} \) and \(B \in \mathbb{R}^{n \times n}\) are the discrete time LTI matrices with 
              \(A = e^{0\Delta t} = I\) and \(B=\Delta t I \).  
              In this simple case, the Forward-Euler integration scheme (on the right) is precise assuming a first-order hold of the control input 
              over the time step.  We can also compute the reachability matrix for \(k\) time steps.

              $$
              \begin{aligned}
              M_k & = \Big[ A^{k-1}B \  A^{k-2}B \ \cdots \  AB \ B \Big] \\ 
              & = \Delta t \Big[ \  I \ \ I  \ \ \cdots  \ \   I  \ \ I \  \Big] 
              \end{aligned}
              $$

              We will use \(\mathbf{x} \in \mathbb{R}^{nT}\) and \(\mathbf{u} \in \mathbb{R}^{nT}\)to represent the rolled out state and control trajectories

              $$
              \begin{aligned}
              \mathbf{x} & = \Big(x\big(0\big),x\big(\Delta t\big),\dots,x\big(\Delta t T\big)\Big), \quad 
              \mathbf{u} = \Big(u\big(0\big),u\big(\Delta t\big),\dots,u\big(\Delta t (T-1)\big)\Big) 
              \end{aligned}
              $$ 

              We can integrate out a control trajectory get the dynamics as 
              $$
              \begin{aligned}
              x(k\Delta t )
              & = x_0 + \sum_{j=0}^{k-1} A^{k-1-j} B u(j\Delta t) + x_0 \\
              & = x_0 + \sum_{j=0}^{k-1} \Delta t  u(j\Delta t) 
              \end{aligned}
              $$
              In vector form this can be written as
              $$
              \begin{aligned}
              \mathbf{x} = \mathbf{H} x_0 + \mathbf{M} \mathbf{u}
              \end{aligned}
              $$
              where \(\mathbf{H} \in \mathbb{R}^{nT \times n}\) and \(\mathbf{M} \in \mathbb{R}^{nT\times nT}\) are given by 

              $$
              \begin{aligned}
              \mathbf{H} 
              = 
              \begin{bmatrix}
              I \\ I \\ I \\ I \\ \vdots \\ I
              \end{bmatrix}, \quad 
              \mathbf{M} 
              = 
              \begin{bmatrix}
              0 & 0 & 0 & \cdots & 0 \\
              B & 0 & 0 & \cdots & 0 \\
              AB & B & 0 & \cdots & 0 \\
              A^2B & AB & B & \cdots & 0 \\
              \vdots & \vdots & \vdots & \ddots &  \vdots \\
              A^{T-1}B & A^{T-2}B & A{T-3}B & \cdots & B 
              \end{bmatrix}
              \end{aligned}
              $$


              </p>


              <b> Initial Control and Trajectory </b>


              <p>
              We first come up with an initial control trajectory, \(\mathbf{u}^{(0)}\), that drives us from the origin to the destination by finding a minimum norm control scheme.  We want to satisfy the equation 
              $$
              \begin{aligned}
              x_T = x_0 + M_T\mathbf{u}^{(0)}
              \end{aligned}
              $$
              Since \(M_T\) is a fat matrix this equation has a subspace of solutions; we can find the minimum norm solution by computing 
              
              $$
              \begin{aligned}
              \mathbf{u}^{(0)} = M_T^\top(M_TM_T^\top)^{-1}(x_T - x_0)
              \end{aligned}
              $$

              In order to compute a diversity of possible trajectories, we may make an additional modification and force trajectories to pass through an intermediate state at the mid point of the time horizon.  If we define this intermediate state as \(x_{T/2}\) and consider a reachability matrix for just half of the time horizon, \(M_{T/2}\), we can define the initial minimum norm control (passing through the intermediate point) as 

              $$
              \begin{aligned}
              \mathbf{u}^{(0)} =  
              \begin{bmatrix}
              M_{T/2}^\top(M_{T/2}M_{T/2}^\top)^{-1}(x_{T/2} - x_0), \\
              M_{T/2}^\top(M_{T/2}M_{T/2}^\top)^{-1}(x_T - x_{T/2})  
              \end{bmatrix}
              \end{aligned}
              $$

              The initial state trajectories \(\mathbf{x}^(0)\) can then be computed by integrating the initial contols.  Several such trajectories are shown here passing through their random middle points.  

                <div class='imgFixed' >
<!--                 <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/scvx/2Dinit.png" width=35%></img>
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/scvx/3Dinit.jpeg" width=35%></img>
 -->                
                <img src="/figs/blog/scvx/2Dinit.png" width=35%></img>
                <img src="/figs/blog/scvx/3Dinit.jpeg" width=35%></img>

                </div>



              Note that in computing the initial control and state trajectories we have ignored the obstacles and we will need to fix this in the next step.  

              </p>

              <b> Successive Convexification </b>

              <p>
              We now want seek to improve our trajectories so that 1) the obstacles are avoided and 2) we reduce the amount of control effort that is employed.  We use the successive convexification scheme developed by Behcet Ackimese and company.  

              Our scheme will involve 


              $$
              \begin{aligned}
              \min_{\partial u,\partial x} & \quad
              w_u \sum_k (u_k+\partial u_k)^\top R_k (u_k+\partial u_k)  + 
              w_s\sum_k s_k^\top s_k \\
              \text{s.t.} & \quad \partial x_{k+1} = A \partial x_k + B \partial u_k, \ \quad \forall k \\
              & \quad G_k \partial x_k - d_k + s_k \geq 0, \ s_k \geq 0 \quad \forall k 
              \end{aligned}
              $$

              </p>



              </div>

                <div class='imgBackground'>
                <div class='imgFixed' >
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/2Dtraj.gif" width=70%></img>
                </div>
                <div class='imgFixed' >
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/3Dtraj.gif" width=70%></img>
                </div>

                </div>

                <div class='imgBackground'>
                <div class='imgFixed' >
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/3Dtraj.gif" width=70%></img>
                </div>
                </div>




      </div>
      </div>
    <!-- <script type='module' src="./matrixo.js"> </script> -->
    <script src="/dcmath/src/extra/includeHTML.js"> </script>

    </body>
  </html>
