<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></link>
    <meta http-equiv="X-UA-Compatible" content="ie=edge" ></link>

    <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.css"
    integrity="sha384-Cqd8ihRLum0CCg8rz0hYKPoLZ3uw+gES2rXQXycqnL5pgVQIflxAUDS7ZSjITLb5"
    crossorigin="anonymous"></link>

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.js"
    integrity="sha384-1Or6BdeNQb0ezrmtGeqQHFpppNd7a/gw29xeiSikBbsb44xu3uAo8c7FwbF5jhbd"
    crossorigin="anonymous"></script>
  <!-- To automatically render math in text elements, include the auto-render extension: -->

  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/contrib/auto-render.min.js"
    integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"
    crossorigin="anonymous"
    onload="renderMathInElement(document.body)">
    </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.2.5/math.min.js"> </script>
  <script src="https://unpkg.com/pts@0.10.5/dist/pts.js"></script>


    <!-- <link rel="stylesheet" href="./css/main.css" ></link> -->


    <style>

.img1 {
  background-color: rgb(0, 0, 255, 0);
  flex: 0 1 auto;
  padding: 0px;
  margin: 0px;
  position: relative;
  top: 0px;
  left: 0px;
  width: 95%;
  aspect-ratio: 1 / 1;
  /* height: 900px; */
}
.img1 .CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  top: 0;
  left: 0;
  position: absolute;
  margin: 0px;
  padding: 0px;
  width: 100%;
  height: 100%;
}

.img2 {
  background-color: rgb(0, 0, 255, 0);
  flex: 0 1 auto;
  padding: 0px;
  margin: 0px;
  position: relative;
  top: 0px;
  left: 0px;
  width: 95%;
  aspect-ratio: 2 / 1;
  /* height: 900px; */
}

.img2 .CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  top: 0;
  left: 0;
  position: absolute;
  margin: 0px;
  padding: 0px;
  width: 100%;
  height: 100%;
}


.CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  position: absolute;
  top: 0;
  left: 0;
  width: 1400px;
  height: 1400px;
}
.eqn1 {
  background-color: rgba(0, 0, 255, 0);
  color: black;
  position: absolute;
  font-size: 16px;
  top: 0px;
  left: 0px;
  z-index: -1;
}





  </style>

  <link rel="stylesheet" href="/css/main.css" ></link>
  <!-- <link rel="stylesheet" href="/main.css" ></link> -->
  

    </head>

    <body>
    <header > <h1> danjcalderone </h1> </header>



    <div w3-include-html="/nav/topics.html"></div>



    <div class="wrapper">
      <div class="sidebar">
      <div w3-include-html="/nav/sidebarBLOG.html"></div>




      </div>
      <div class=main_content>


        <h1><div id="header">
          Spanning Trees & Cycles
        </div></h1>


        <div class="section basic" >



<!--                   <div class='imgFixed'>
          <div class="slideshow-container flips" id='INNERPRODX' any='6' style="width:50%"></div>
          </div>
 -->


        <div class="txt" style="padding:0px 20px">


          <p> Algebraic graph theory is a powerful mathematical discipline that derives matrices from graphs, studies their linear algebraic properties, and then applies those insights to graph problems.  It has become a must-know area of mathematics for many subdisciplines of optimization and machine learning such as Markov decision processes, reinforcement-learning, path-planning, and commodity optimization.  In this post, we detail a fundamental decomposition result for the well-known node-edge incidence matrix of a graph.  
          </p>
        </div>


        <div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/graph_primal_dual1.png" width=95%></img> </div>


        <div class="txt" style="padding:0px 20px">


              <b> Basic Graph Setup</b>



              <p> 
              A graph \(\mathcal{G}=(\mathcal{V},\mathcal{E})\) is a mathematical object consisting of discrete states (referred to as nodes or vertices) \(\mathcal{V}\) and a connectivity structure between them, ie. a set of edges \(\mathcal{E}\).  We will focus mostly on directed graphs, ie. graphs where each edge has an orientation "from one node to another node".  In many optimization problems involving graphs, we will be considered with variables that take values on either each edge or each node.  For example, in many routing or flow optimization problems, we will define a vector \(x \in \mathbb{R}^{|\mathcal{E}|}\) where each \(x_j\) is the amount of mass or flow on edge \(j \in \mathcal{E}\).  Often \(x\) will represent the indicator vector for a path or flow distribution of some commodity.  We illustrate one such vector \(x\) in the figure below.  On the other hand, we will also often want to define variables on the nodes \(v \in \mathbb{R}^{|\mathcal{V}|}\) where \(v_i\) is a value on node \(i \in \mathcal{V}\).  \(v_i\) can be thought of as the ``height'' of that node  illustrated in the figure below as well.  In physics problems, \(v\) often corresponds to heights, voltages, or some other potential energy indicator.  In flow optimization problems, often \(v\) represents some cost-to-go measure from that node to the sink.  
              </p>


              <b> Node-Edge Incidence Matrix</b>

<p>

  Algebraic graph theory defines many types of matrices for each graph, but perhaps the most fundamental is the node-edge incidence matrix that we will call \(E \in \mathbb{R}^{|\mathcal{V}|\times |\mathcal{E}|}\).  

  $$
  \begin{aligned}
  E_{ij} = \begin{cases}
  -1 & \text{ if edge \(j\) starts at node \(i\) } \\
  1 & \text{ if edge \(j\) ends at node \(i\) } \\
  0 & \text{ otherwise}
  \end{cases},
    \end{aligned}
  $$


  Each row corresponds to a node and each column corresponds to an edge.  The row for each node contains a -1 if the edge comes out of the node, a 1 if the edge goes into that node, and a 0 otherwise.  

</p>
</div>
<div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/incidence_row.png" width=85%></img> </div>

<div class="txt" style="padding:0px 20px">
<p>

  Equivalently, the column for each edge contains -1 for the node the edge starts from and a 1 for the node the edge ends at and a 0 otherwise.  

</p>
</div>

<div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/incidence_col.png" width=85%></img> </div>


<div class="txt" style="padding:0px 20px">
<p>

  Each row of the incidence matrix represents a mass conservation equation at that particular node and as a result, for flow optimization problems we often use constraints of the form shown below where \(S \in \mathbb{R}^{|\mathcal{E}|}\) is a source-sink vector that has the same form as a column of the incidence matrix and indicates the node the flow starts from (the source) and the node the flow goes to (the sink). This incidence matrix shows up in many physica equations (circuit balances, etc) and many optimization problems especially those focused on flow using the above constraint (shortest path optimization, commodity flow optimization, etc).  Extensions of it are also form the foundation for Markov decision process analysis. 


 </p>
</div>





<div class="txt" style="padding:0px 20px">


              <b> Spanning Trees & Cycles</b>
<p> 
  In a moment we will introduce a decomposition of incidence matrices that is based on the ideas of trees and cycles of a graph.  For a completely connected graph, a spanning tree is a subset of the edges of a graph that connect all the nodes without forming any cycles. Because of this, each spanning tree has exactly \(\mathcal{V}-1\) edges, one less than the number of nodes. Every other edge that is not in the spanning tree corresponds to a specific cycle of the graph that can be formed by taking that edge along with other edges in the spanning tree.  The spanning tree essentially already contains all the edges of that the cycle and the non-spanning tree edge is the edge left out.  It can also be shown that the set of cycles corresponding to each of the non-spanning tree edges forms a linearly independent set and actually a basis for the full cycle space.  (More details in the nullspace section below.)   We illustrate these cycles here given a spanning tree of the graph shown.  


</p>

</div>

<div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/treeandcycles.png" width=85%></img> </div>


<div class="txt" style="padding:0px 20px">

  <p>
  This cycle idea also allows us to construct any non-spanning tree edge as a linear combination of spanning tree edges.  In particular, to get from the start node to the end node of the non-spanning tree edge, we could simply traverse the edge or we could walk the other way around the cycle using edges in the spanning tree to have the same effect.  Algebraically, this is equivalent to constructing a column of the incidence (not in the spanning tree) from other columns (in the spanning tree) by taking a linear combination with 1's and -1's.  We add the column if we are traversing the edge along it's orientation; we subtract the column if we are traversing the edge in the opposite direction.  

</p>


</div>
<div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/summingedges.png" width=85%></img> </div>


<div class="txt" style="padding:0px 20px">


<b> Tree-Cycle Decomposition </b>
<p>

  From the above discussion, we have that we can decompose graph incidence matrices in the following way.  For a fully connected graph, we can write 


  $$
  \begin{aligned}
  E = T\Big[ \ I \ \  M \ \Big] = \Big[ \ T \ \  TM \ \Big]
  \end{aligned}
  $$



  Here \(T \in \mathbb{R}^{|\mathcal{V} \times \mathcal{V}-1|}\) is the incidence matrix for a spanning tree and \(M\) is a matrix related to the cycles.  Explicitly, each column of \(M\) corresponds to a linear combination of spanning tree edges that constructs an edge not in the spanning tree.  

  Note here that the dimensions of \(T\) are fixed since spanning trees must always have one less edge than the number of nodes. Note also that for ease of notation, we have assumed that the first \(\mathcal{V}-1\) edges of the graph form the spanning tree.  If this is not the case, the identity matrix in the above form will be shuffled throughout the \(M\) matrix.  (This corresponds to a simple reordering of the edges so we can assume the above form without loss of generality.)  We illustrate the structure of this decomposition according to the tree and cycles as discussed above here. 

</p>


</div>

<div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/decomposition1.png" width=85%></img> </div>


<div class="txt" style="padding:0px 20px">

  In the general case when the graph may not be full connected, this expansion becomes 

  $$
  \begin{aligned}
  E =
  \underbrace{
  \begin{bmatrix}
  T_1 & \cdots & 0 \\
  \vdots & \ddots & \vdots \\
  0 & \cdots & T_k
  \end{bmatrix}}_{F}
  \begin{bmatrix}
  I & \cdots & 0 &  M_1 & \cdots & 0\\
  \vdots & \ddots & \vdots & \vdots & \ddots & \vdots  \\
  0 & \cdots & I & 0  & \cdots & M_k
  \end{bmatrix}
  \end{aligned}
  $$

  where \(F\) is the incidence matrix for what is called a spanning forest (a set of spanning trees) where each tree corresponds to one of the \(k\) connected components, that gives the block diagonal structure.



</p>
 

 <p> We give two examples of this decomposition spelled out in detail with images.  </p>

        <b> Example 1: </b>

      <div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/incidence_cycles1.png" width=65%></img> </div>

<div class="txt" style="padding:0px 20px">

      <b> Example 2: </b>
    </div>
      <div class='imgFixed' > <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/graph1/incidence_cycles2.png" width=65%></img> </div>





<div class="txt" style="padding:0px 20px">


<b> Fundamental Subspaces</b>

<p> The above construction gives a clear picture of each of the four fundamental subspaces for the incidence matrix and their interpretation in terms of edge flows and potential values.  We detail each of the here</p>



<b> Range of \(E\): Total mass in and out of nodes </b>
<p> 

  Taking linear combinations of the columns of \(E\) gives a vector in \(\mathbb{R}^{|\mathcal{V}|}\).  For a particular edge flow \(x\), each element of \(Ex\) is the flow in that node minus the flow out, ie. the total mass in or out of the node depending on the sign.  

</p>


<b> Nullspace of \(E\): Cycle Flow Space </b>

<p> 

  The nullspace is defined by the equation \(Ex=0\).  This corresponds to an edge flow vector that conserves mass at each node which intuitively corresponds to cyclic flows in the graph.  The above decomposition allows us to make this explicit.  Specifically, we can write a basis for the nullspace as 

$$
\begin{aligned}
C = \begin{bmatrix} -M \\ I \end{bmatrix}
\end{aligned}
$$
Multiplying out we can see immediately that \(EC = T(-M + M) = 0\).  Furthermore, we have that each column of \(C\) is linearly independent because of the identity in the bottom half.  Rigorously, this is because
$$
\begin{aligned}
Cz = 0 \implies \begin{bmatrix} Mz \\ z \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \end{bmatrix} \implies z = 0
\end{aligned}
$$ 

which is the definition of linear independence. A slightly longer argument shows that \(C\) spans the nullspace of \(E\) as well.  Rigorously, any \(x\) such that \(Ex=0\) can be written as \(x = Cz\) since we can decompose \(x\) as \(x = [x' ; x'']\) and write 

$$
\begin{aligned}
0 = Ex = T(x' + M x'') & \implies x' + M x'' = 0 \\
& \implies x' = -M x'' \\
& \implies x = \begin{bmatrix} -M \\ I \end{bmatrix} x'' \\
& \implies x = Cz 
\end{aligned}
$$
with \(z = x''\).  Note that in the middle step we have used the fact that the columns of \(T\) are linearly independent.  We thus have that the columns of \(C\) each indicator vectors for a cycle of the graph form a basis for the nullspace of \(E\).  Any other flow where mass is conserved can be written as a linear combination of these cycles. 
 </p>



<b> Nullspace of \(E^\top\): Constant Node Heights  </b>
<p> 
Note that each column of the incidence matrix sums to 0 and thus the left nullspace or nullspace of \(E^\top\) is given by any constant vector, such as the vector of all 1's.  Relative to the flow variables this implies that \(\mathbf{1}^\top Ex =0\) for any \(x\), ie. any vector of the form \(Ex\) has the same of amount of entering and exiting the network.  Relative to the node variables, left multiplying by any node variable \(v\), \(v^\top E\) is independent of any constant shift of \(v\).  

</p>


<b> Range of \(E^\top\): Edge Tension Space:  </b>

<p> 
  Lastly, any linear combination of the rows of the form \(v^\top E\) gives the relative difference along the edges for different node potential values.  As discussed in the previous section, this is independent of any constant shift.  

</p>


            </div>



<!--                 <div class='imgFixed' >
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_basic2.jpeg" width=75%></img>
 -->                <!-- <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_gif_main.gif" width=75%></img> -->
                
<!--                 <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/scvx/2Dtraj_bounds.gif" width=40%></img>
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/scvx/3Dtraj_bounds.gif" width=55%></img>
 -->                </div>








          </div>
        </div>
      </div>



      
    <!-- <script type='module' src="./matrixo.js"> </script> -->










    <!-- <script type='module' src="./matrixo.js"> </script> -->
    <script src="/dcmath/src/extra/includeHTML.js"> </script>
    <!-- <script type='text/javascript' src="/dcmath/src/extra/flip.js"></script>     -->

<!--     <script>
    // const slideIndexes ={'SCALARMULT':1, 'DOTPRODLEN':1, 'DOTPRODANGLE':1}
    const slideIndexes ={'INNERPRODX':1, 'INNERPRODY':1,'INNERPROD_ORTHO':1}
    addSlides('INNERPRODX',slideIndexes);
    showSlides('INNERPRODX',slideIndexes['INNERPRODX'],slideIndexes);
    addSlides('INNERPRODY',slideIndexes);
    showSlides('INNERPRODY',slideIndexes['INNERPRODY'],slideIndexes);
    addSlides('INNERPROD_ORTHO',slideIndexes);
    showSlides('INNERPROD_ORTHO',slideIndexes['INNERPROD_ORTHO'],slideIndexes);

    </script>
 -->

    </body>
  </html>
