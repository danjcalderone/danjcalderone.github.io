<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></link>
    <meta http-equiv="X-UA-Compatible" content="ie=edge" ></link>

    <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.css"
    integrity="sha384-Cqd8ihRLum0CCg8rz0hYKPoLZ3uw+gES2rXQXycqnL5pgVQIflxAUDS7ZSjITLb5"
    crossorigin="anonymous"></link>

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.js"
    integrity="sha384-1Or6BdeNQb0ezrmtGeqQHFpppNd7a/gw29xeiSikBbsb44xu3uAo8c7FwbF5jhbd"
    crossorigin="anonymous"></script>
  <!-- To automatically render math in text elements, include the auto-render extension: -->

  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/contrib/auto-render.min.js"
    integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"
    crossorigin="anonymous"
    onload="renderMathInElement(document.body)">
    </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.2.5/math.min.js"> </script>
  <script src="https://unpkg.com/pts@0.10.5/dist/pts.js"></script>


    <!-- <link rel="stylesheet" href="./css/main.css" ></link> -->


    <style>

.img1 {
  background-color: rgb(0, 0, 255, 0);
  flex: 0 1 auto;
  padding: 0px;
  margin: 0px;
  position: relative;
  top: 0px;
  left: 0px;
  width: 95%;
  aspect-ratio: 1 / 1;
  /* height: 900px; */
}
.img1 .CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  top: 0;
  left: 0;
  position: absolute;
  margin: 0px;
  padding: 0px;
  width: 100%;
  height: 100%;
}

.img2 {
  background-color: rgb(0, 0, 255, 0);
  flex: 0 1 auto;
  padding: 0px;
  margin: 0px;
  position: relative;
  top: 0px;
  left: 0px;
  width: 95%;
  aspect-ratio: 2 / 1;
  /* height: 900px; */
}

.img2 .CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  top: 0;
  left: 0;
  position: absolute;
  margin: 0px;
  padding: 0px;
  width: 100%;
  height: 100%;
}


.CANVAS {
  background-color: rgb(0, 0, 255, 0);
  z-index: 1;
  position: absolute;
  top: 0;
  left: 0;
  width: 1400px;
  height: 1400px;
}
.eqn1 {
  background-color: rgba(0, 0, 255, 0);
  color: black;
  position: absolute;
  font-size: 16px;
  top: 0px;
  left: 0px;
  z-index: -1;
}





  </style>

  <link rel="stylesheet" href="/css/main.css" ></link>
  <!-- <link rel="stylesheet" href="/main.css" ></link> -->
  <link rel="stylesheet" href="/css/main.css" ></link>

    </head>

    <body>
    <header > <h1> danjcalderone </h1> </header>



    <div w3-include-html="/nav/topics.html"></div>



    <div class="wrapper">
      <div class="sidebar">
      <div w3-include-html="/nav/sidebarBLOG.html"></div>




      </div>
      <div class=main_content>


        <h1><div id="header">
          Simplex Method: Column Geometry
        </div></h1>


        <div class="section basic" >
        

        <div class="txt" style="padding:40px">



              <b> Simplex Method </b>


              <p>
              Understanding the column geometry of the simplex method is a good way to understand and remember the details of the algorithm. In this post, we detail the well-understood column geometry of the simplex method for a straightforward example.  This example may seem somewhat contrived but it does elucidate the geometry clearly. 
              </p>


              <b> Basic Canoncial Problem Setup </b>

              <p>
              The basic simplex method considers linear programs written in the following canonical form.  
               $$
              \begin{aligned}
              \max_{x} & \quad c^\top x \\
              \text{s.t.} & \quad Ax =b, \ \ x \geq 0
              \end{aligned}
              $$
              for \(x \in \mathbb{R}^n\), \(c \in \mathbb{R}^n\), \(A \in \mathbb{R}^{m \times n}\), and \(b \in \mathbb{R}^m\).  Note that this is in fact a quite general form encompassing any equality and inequality constraints  For an equality constraint of the form \(Ax = b\) where \(x\) does not need to be positive we can simply include two positive variables \(x_+ \in \mathbb{R}^n\) and \(x_- \in \mathbb{R}^n \) and expand the constraint to read 

              $$
              \begin{aligned}
              \Big[ \ A \ \ -A \Big] \begin{bmatrix} x_+ \\ x_- \end{bmatrix}
              = b, \quad x_+ \geq 0, \  x_- \geq 0
              \end{aligned}
              $$
              Here both \(x_+\) encodes any positive values of \(x\) and \(x_-\) encodes any negative values and \(x = x_+ + x_- \).  
              Furthermore, if we have an inequality constraint instead of the form \(Ax \geq b \) can further introduce positive slack variables \(s \in \mathbb{R}^m\) and write the constraints as
              $$
              \begin{aligned}
              \Big[ \ A \ \ -A \ \ \ -I \Big] \begin{bmatrix} x_+ \\ x_-  \\ s\end{bmatrix}
              = b, \quad x_+ \geq 0, \  x_- \geq 0, \ s \geq 0
              \end{aligned}
              $$
              </p>



              <b> Intuitive Problem Description </b>

              <p>
              Many basic linear programming examples can be well understood in the context of a basic budgeting problem.  We consider the following linear program in expanded form 

               $$
              \begin{aligned}
              \max_{x} & \quad c_1 x_1 + \cdots + c_n x_n \\
              \text{s.t.} & \quad 
              \begin{bmatrix}
              A_{11} x_1 + \cdots + A_{1n} x_n \\
              \vdots \\
              A_{m1} x_1 + \cdots + A_{mn} x_n
              \end{bmatrix} = 
              \begin{bmatrix} b_1 \\ \vdots \\ b_m \end{bmatrix}
              , \quad 
              \begin{bmatrix} x_1 \\ \vdots \\ x_n \end{bmatrix} \geq 0
              \end{aligned}
              $$

              For our example, think of this problem as a company that wants to allocate percentage of it's manpower to various jobs that it can choose.  The column index \(j \in \{1,\dots,n\}\) is the job index, \(x_j\) is the number of jobs taken of that particular type, and \(c_j\) is the reward received for completing each of those jobs.  The row index \(i \in \{1,\dots,m\}\) is the resource index corresponding to different resources that the company has to budget: time, money, equipment, etc.  \(b_i\) is the overall budget for resource \(i\) and \(A_{ij}\) is the rate at which the company uses resource \(i\) to do job \(j\).  (Note that here we are assuming that there are infinite number of jobs of each type that the company could take given the manpower, ie. (\(x_j\) has no upper bound); and also that it is fine for the company to completely only part of a job and get paid for part of it, ie. \(x_j\) does not have to be an integer.)  To display this clearly, we write out the problem data in a table format that mirrors the matrix equation and will also be useful in the algorithm given below.  We consider a simple example where the company considers three different resources \(m=3\), money, time, and equipment \(m = 3\) and there are n different jobs that can be considered \(n=8\)

              $$
              \begin{aligned}
              & \qquad \leftarrow \quad \text{jobs} \quad \rightarrow \\
              & 
               \ \Big[
              \ \ \ c_1 \ \quad c_2 \ \quad \cdots \quad \ c_n \ \ 
              \Big]
               \\
              \begin{matrix}
              \uparrow \\
              \text{Resources} \\
              \downarrow
              \end{matrix}
              \quad 
              \begin{matrix}
              \text{time} \\
              \text{money} \\
              \text{equip} 
              \end{matrix}
              \quad         
               & 
              \begin{bmatrix}
              A_{11} & A_{12} &\cdots & A_{1n} \\
              A_{21} & A_{12} & \cdots & A_{2n} \\
              A_{31} & A_{12} & \cdots & A_{3n} 
              \end{bmatrix}
              \quad 
              \begin{bmatrix}
              b_{1} \\
              b_{2} \\
              b_{3} 
              \end{bmatrix}
              \ \ 
              \begin{matrix}
              \uparrow \\
              \text{Budgets} \\
              \downarrow
              \end{matrix}
              \end{aligned}
              $$

              We take a moment to consider the rows and columns of \(A\) in terms of this intuition.  Each row of \(A\) gives the cost on a particular resource of taking each job. For example the first row of is the amount of time required (per worker) for each job.  


              $$
              \begin{aligned}
              & \qquad \leftarrow \quad 
              \begin{matrix}
              \text{Amt. of resource \(i\)} \\
              \text{required for each job}
              \end{matrix}
              \quad \rightarrow \\
               & 
              \begin{bmatrix}
              A_{i1} & A_{i2} & A_{i3}  & \cdots & A_{i(n-2)} & A_{i(n-1)} & A_{in} 
              \end{bmatrix}
              \end{aligned}
              $$

              Each column, on the other hand gives the impact of each job on the budget.  For example, the first column is how much time, money, and equipment the first job type will take to complete.

              $$
              \begin{aligned}
              \begin{bmatrix}
              A_{1j} \\
              A_{2j} \\
              A_{3j} 
              \end{bmatrix}
              \ \ 
              \begin{matrix}
              \text{time} \\
              \text{money} \\
              \text{equip}
              \end{matrix}
              \quad 
              \begin{matrix}
              \text{required for} \\
              \text{job \(j\)} 
              \end{matrix}
              \end{aligned}
              $$


              The goal of the linear program then is to find which jobs to take to make as much money as possible within each budget. 




            </p>

            <b> Tableu Format </b>b
            <p>
              Unlike many other algorithms, the simplex method is one that can be fairly easily implemented by hand, similar to solving a system of equations.  Indeed, in some sense, the simplex method can be thought as the next generation to Gaussian elimination both in terms of usefulness and complexity.   To this end, the data for a linear program is usually formatted in what is called a tableau format in order to conveniently perform row-reduction operations on both \(A\),\(b\) and \(c\) together.  This format is given as follows
              $$
              \begin{aligned}
              \begin{bmatrix} 
              1 & c^\top & 0 \\ 
              0 & A &  b
              \end{bmatrix} 
              \end{aligned}
              $$
              where the lower left zero block is a column in \(\mathbb{R}^m\) and the upper right zero is in \(\mathbb{R}\). This upper right zero will turn into the (negative) of the optimal objective value as we perform row reduction (or pivot) operations.    Note that many references will negate \(c\) in the top row causing the upper right 0 to become the actual objective value as the algorithm is performed.  We leave \(c\) positive since it amends itself more to our geometric interpretation; both options give the same answer up to a sign flip. 



            </p>


              <b> Column Geometry </b>

              <p>
              We now turn to the column geometry of the basic canonical form.  
              For the majority of this post, we will take \(m = 2\) (two rows) and \(n = 12\) (twelve columns).  We will choose \(c\), \(A\), and \(b\) to be as follows given in tableau format below.
              </p>              

              <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_basic_tableau.jpeg" width=50%></img>

              <p>
              The column geometry of \(A\) and \(b\) is shown here on the left in 2D; the column geometry of the full tableau is shown here on the right in 3D. 
            </p>




              <b> Geometry: \(Ax = b\) </b>
              <p>
              From a column geometry perspective the equality constraint \(Ax = b\) requires that \(x\) be a positive linear combination that constructs \(b\) from the columns of \(A\). We give several examples here.  



              Note that the fact that \(b \in \mathbb{R}^2\) means that \(x\) will in general have at least two elements that are nonzero. 
              Note that some of these combinations have more positive elements than others.  We can show, however, that for any optimal value of the linear program there will be an \(x\) that achieves that value with only two (in general \(m\)) non-zero values. Moreover, 
              suppose if we have an optimal \(x\) with more than two nonzero coordinates shifting the mass of \(x\) to any two coordinates that originally had nonzero elements will keep the overall reward the same.  


              <!-- The proof is straightforward and we show it for the general case.  Let \(x\) be any optimal solution and WLOG assume that the first \(m\) elements of \(x\) are nonzero.  Partition \(x\) into \(x' \in \mathbb{R}^m\) and \(x'' \in\mathbb{R}^{n-m}\) (and \(c\) and \(A\) similarly) and write out the objective function as follows 
              $$
              x = \begin{bmatrix} x' \\ x'' \end{bmatrix}, \qquad 
              c^\top x = c'^\top x' + c''^\top x'' = \textbf{opt}
              $$
              where \(\textbf{\opt}\) is the optimal value of the program.  
              Note that the constraints guarantee that 
              \(A'x'+A''x'' = b)
               -->


            </p>

            <b> Geometry: Tableu  </b>

            <p>

            The addition of \(c\) to construct the tableau raises the tips of each column vector \(A_j\) (in a third dimension) to the height of \(c_j\) illustrated here.
          </p>

           <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_basic1_nomat.jpeg" width=55%></img>
                <!-- <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_gif_main.gif" width=75%></img> -->
                
<!--                 <img src="/figs/blog/scvx/2Dtraj_bounds.gif" width=40%></img>
                <img src="/figs/blog/scvx/3Dtraj_bounds.gif" width=55%></img>
 -->                
<!-- </div> -->



  <p>
            For any linear combination \(x\) such that \(Ax = b\), the vector \(\xi = [c^\top x ; \ Ax ]\) will be directly above (or below) the point \(\bar b = [0; \ b]\) in the 3D space. The geometry of this is illustrated here.  
            </p>

        <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_basic2_nomat.jpeg" width=55%></img>



            <p>
             Geometrically, then the goal of solving the linear program is to find a positive linear combination of \(x\) such that \(Ax = b\) such that the \(\xi\) is as high above the point \(\bar b\) as possible, ie. to maximize \(c^\top x\).  From the discussion above, we have that any optimal solution can be reduced to a solution with only two basis vectors and so because of this we will swap basis vectors in and out in order to increase the height (\(c^\top x \)) until we cannot make any more improvements.  In the next section we will get into the details of this method, but here we give a visualization of what the full algorithm will look like geometrically.  Note how the height of \(\xi\) continuously increases and how at the algorithms termination there are no more basis vectors we can swap in that will increase this height.  

            </p>





              </div>

                <div class='imgFixed' >
                <!-- <img src="/figs/blog/simplex/simplex_gif_main.gif" width=90%></img> -->
                <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_gif_main2.gif" width=75%></img>
                
<!--                 <img src="/figs/blog/scvx/2Dtraj_bounds.gif" width=40%></img>
                <img src="/figs/blog/scvx/3Dtraj_bounds.gif" width=55%></img>
 -->                </div>





              <div class="txt" style="padding:40px">
              <b> Algorithm Details </b>
              <p>
              For initially simplicity, we will assume that we've constructed an initial basic solution \(x\geq 0\) such that \(Ax = b\) where \(x\) has only two nonzero components.   A general procedure for constructing this initial solution can be found here (INSERT LINK). In many problems this initial solution can also be selected quickly by the user from intuition.  From this initial basic solution, we want to find which columns to swap in in order to improve our cost.  Before 
              <p>











              Detailed description
              </p>
              </div>



                <div class='imgFixed' >
                <img src="/figs/blog/simplex/simplex_basic2.jpeg" width=75%></img>
                <!-- <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_gif_main.gif" width=75%></img> -->
                
<!--                 <img src="/figs/blog/scvx/2Dtraj_bounds.gif" width=40%></img>
                <img src="/figs/blog/scvx/3Dtraj_bounds.gif" width=55%></img>
 -->                </div>





                <div class='imgFixed' >
                <img src="/figs/blog/simplex/simplex_gif_main2.gif" width=75%></img>
                <!-- <img src="/Users/dan/Documents/danjcalderone.github.io/figs/blog/simplex/simplex_gif_main.gif" width=75%></img> -->
                
<!--                 <img src="/figs/blog/scvx/2Dtraj_bounds.gif" width=40%></img>
                <img src="/figs/blog/scvx/3Dtraj_bounds.gif" width=55%></img>
 -->                </div>


          </div>
        </div>
      </div>










    <!-- <script type='module' src="./matrixo.js"> </script> -->
    <script src="/dcmath/src/extra/includeHTML.js"> </script>

    </body>
  </html>
